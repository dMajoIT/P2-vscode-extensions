 =================================================================================================
   File....... jm_fullduplexserial.spin2
   Purpose.... Buffered serial communications using smart pins
               -- mostly matches FullDuplexSerial from P1
               -- does NOT support half-duplex communications using shared RX/TX pin
   Authors.... Jon McPhalen
               -- based on work by Chip Gracey
               -- see below for terms of use
   E-mail..... jon.mcphalen@gmail.com
   Started....
   Updated.... 24 AUG 2020
 =================================================================================================

Note: Buffer size no longer has to be power-of-2 integer.

Note: The dec(), bin(), and hex() methods will no longer require the digits parameter as
in older versions of FullDuplexSerial. Use fdec(), fbin(), and fhex() for code that
requires a specific field width.


The smart pin uarts use a 16-bit value for baud timing which can limit low baud rates for
some system frequencies -- beware of these limits when connecting to older devices.

Baud     20MHz    40MHz    80MHz    100MHz    200MHz    300MHz
------    -----    -----    -----    ------    ------    ------
300       No       No       No        No        No        No
600      Yes       No       No        No        No        No
1200      Yes      Yes       No        No        No        No
2400      Yes      Yes      Yes       Yes        No        No
4800      Yes      Yes      Yes       Yes       Yes       Yes


Object "jm_fullduplexserial" Interface:

pub null()
pub tstart(baud) : result
pub start(rxpin, txpin, mode, baud) : result | baudcfg, spmode
pub stop()
pub rx() : b
pub rxcheck() : b
pub rxtime(ms) : b | mstix, t
pub rxtix(tix) : b | t
pub available() : count
pub rxf4lush()
pub tx(b) | n
pub txn(b, n)
pub str(p_str)
pub substr(p_str, len) | b
pub padstr(p_str, width, pad)
pub txflush()
pub fstr0(p_str)
pub fstr1(p_str, arg1)
pub fstr2(p_str, arg1, arg2)
pub fstr3(p_str, arg1, arg2, arg3)
pub fstr4(p_str, arg1, arg2, arg3, arg4)
pub fstr5(p_str, arg1, arg2, arg3, arg4, arg5)
pub fstr6(p_str, arg1, arg2, arg3, arg4, arg5, arg6)
pub format(p_str, p_args) | idx, c, asc, field, digits
pub fmt_number(value, base, digits, width, pad)
pub dec(value)
pub fdec(value, digits)
pub jdec(value, digits, width, pad)
pub dpdec(value, dp)
pub jdpdec(value, dp, width, pad)
pub hex(value)
pub fhex(value, digits)
pub jhex(value, digits, width, pad)
pub oct(value)
pub foct(value, digits)
pub joct(value, digits, width, pad)
pub qrt(value)
pub fqrt(value, digits)
pub jqrt(value, digits, width, pad)
pub bin(value)
pub fbin(value, digits)
pub jbin(value, digits, width, pad)

__________
pub null()

 This is not a top level object

_________________________
pub tstart(baud) : result

 Start FDS with default pins/mode for terminal

______________________________________________________________
pub start(rxpin, txpin, mode, baud) : result | baudcfg, spmode

 Start simple serial coms on rxpin and txpin at baud
 -- rxpin... receive pin (-1 if not used)
 -- txpin... transmit pin (-1 if not used)
 -- mode.... %0xx1 = invert rx
             %0x1x = invert tx
             %01xx = open-drain/open-source tx

__________
pub stop()

 Stop serial driver
 -- frees a cog if driver was running

____________
pub rx() : b

 Pulls byte from receive buffer if available
 -- will wait if buffer is empty

_________________
pub rxcheck() : b

 Pulls byte from receive buffer if available
 -- returns -1 if buffer is empty

_____________________________
pub rxtime(ms) : b | mstix, t

 Wait ms milliseconds for a byte to be received
 -- returns -1 if no byte received, $00..$FF if byte

______________________
pub rxtix(tix) : b | t

 Waits tix clock ticks for a byte to be received
 -- returns -1 if no byte received

_______________________
pub available() : count

 Returns # of bytes waiting in rx buffer

______________
pub rxf4lush()

 Flush receive buffer

_____________
pub tx(b) | n

 Move byte into transmit buffer if room is available
 -- will wait if buffer is full

_____________
pub txn(b, n)

 Emit byte n times

______________
pub str(p_str)

 Emit z-string at p_str

__________________________
pub substr(p_str, len) | b

 Emit len characters of string at p_str
 -- aborts if end of string detected

_____________________________
pub padstr(p_str, width, pad)

 Emit p_str as padded field of width characters
 -- pad is character to use to fill out field
 -- positive width causes right alignment
 -- negative width causes left alignment

_____________
pub txflush()

 Wait for transmit buffer to empty
 -- will delay one byte period after buffer is empty
    Escaped characters

      \\          backslash char
      \%          percent char
      \q          double quote
      \b          backspace
      \t          tab (horizontal)
      \n          new line (vertical tab)
      \r          carriage return
      \nnn        arbitrary ASCII value (nnn is decimal)

    Formatted arguments

      %w.pf       print argument as decimal width decimal point
      %[w[.p]]d   print argument as decimal
      %[w[.p]]u   print argument as unsigned decimal
      %[w[.p]]x   print argument as hex
      %[w[.p]]o   print argument as octal
      %[w[.p]]q   print argument as quarternary
      %[w[.p]]b   print argument as binary
      %[w]s       print argument as string
      %[w]c       print argument as character (

                  -- w is field width
                     * positive w causes right alignment in field
                     * negative w causes left alignment in field
                  -- %ws aligns s in field (may truncate)
                  -- %wc prints w copies of c
                  -- p is precision characters
                     * number of characters to use, aligned in field
                       -- prefix with 0 if needed to match p
                       -- for %w.pf, p is number of digits after decimal point

________________
pub fstr0(p_str)

 Emit string with formatting characters.

______________________
pub fstr1(p_str, arg1)

 Emit string with formatting characters and one argument.

____________________________
pub fstr2(p_str, arg1, arg2)

 Emit string with formatting characters and two arguments.

__________________________________
pub fstr3(p_str, arg1, arg2, arg3)

 Emit string with formatting characters and three arguments.

________________________________________
pub fstr4(p_str, arg1, arg2, arg3, arg4)

 Emit string with formatting characters and four arguments.

______________________________________________
pub fstr5(p_str, arg1, arg2, arg3, arg4, arg5)

 Emit string with formatting characters and five arguments.

____________________________________________________
pub fstr6(p_str, arg1, arg2, arg3, arg4, arg5, arg6)

 Emit string with formatting characters and six arguments.

______________________________________________________
pub format(p_str, p_args) | idx, c, asc, field, digits

 Emit formatted string with escape sequences and embedded values
 -- p_str is a pointer to the format control string
 -- p_args is pointer to array of longs that hold field values
    * field values can be numbers, characters, or pointers to strings
 Parse one or two numbers from string in n, -n, n.n, or -n.n format
 -- dpoint separates values
 -- only first # may be negative
 -- returns pointer to 1st char after value(s)

_______________________________________________
pub fmt_number(value, base, digits, width, pad)

 Emit value converted to number in padded field
 -- value is converted using base as radix
    * 99 for decimal with digits after decimal point
 -- digits is max number of digits to use
 -- width is width of final field (max)
 -- pad is character that fills out field

______________
pub dec(value)

 Emit value as decimal

_______________________
pub fdec(value, digits)

 Emit value as decimal using fixed # of digits
 -- may add leading zeros

___________________________________
pub jdec(value, digits, width, pad)

 Emit value as decimal using fixed # of digits
 -- aligned in padded field (negative width to left-align)
 -- digits is max number of digits to use
 -- width is width of final field (max)
 -- pad is character that fills out field

____________________
pub dpdec(value, dp)

 Emit value as decimal with decimal point
 -- dp is number of digits after decimal point

_________________________________
pub jdpdec(value, dp, width, pad)

 Emit value as decimal with decimal point
 -- aligned in padded field (negative width to left-align)
 -- dp is number of digits after decimal point
 -- width is width of final field (max)
 -- pad is character that fills out field

______________
pub hex(value)

 Emit value as hexadecimal

_______________________
pub fhex(value, digits)

 Emit value as hexadecimal using fixed # of digits

___________________________________
pub jhex(value, digits, width, pad)

 Emit value as quarternary using fixed # of digits
 -- aligned inside field
 -- pad fills out field

______________
pub oct(value)

 Emit value as octal

_______________________
pub foct(value, digits)

 Emit value as octal using fixed # of digits

___________________________________
pub joct(value, digits, width, pad)

 Emit value as octal using fixed # of digits
 -- aligned inside field
 -- pad fills out field

______________
pub qrt(value)

 Emit value as quarternary

_______________________
pub fqrt(value, digits)

 Emit value as quarternary using fixed # of digits

___________________________________
pub jqrt(value, digits, width, pad)

 Emit value as quarternary using fixed # of digits
 -- aligned inside field
 -- pad fills out field

______________
pub bin(value)

 Emit value as binary

_______________________
pub fbin(value, digits)

 Emit value as binary using fixed # of digits

___________________________________
pub jbin(value, digits, width, pad)

 Emit value as binary using fixed # of digits
 -- aligned inside field
 -- pad fills out field



  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

